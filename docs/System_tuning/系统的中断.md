## 中断

Linux 使用中断来响应硬件设备的请求机制, 它会打断进程的正常调度和执行, 然后调用内核中的中断处理程序来响应设备请求.

中断其实是一种 **异步的事件处理机制，可以提高系统的并发处理能力** ,也就是说内核正常调度进程运行,当中断请求来了以后,转而去执行中断,而不是一直查看是否有中断请求.

中断处理会打断其他程序的运行,中断处理程序在响应中断时,还会临时关闭中断。过长的中断处理时间会导致如下问题:

1. 影响系统程序正常调度和执行的时间.
2. 上一次中断处理完成之前,其他中断都不能响应,也就是说中断有可能会丢失.

所以系统把中断事件分成了 2 部分 **软中断**, **硬中断**

### 软中断和硬中断

上面说过长的中断处理程序会导致系统不能正常处理其他请求, 所以将中断分成了 2 部分:

1. 上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作 **特点是快速执行**
2. 下半部用来延迟处理上半部未完成的工作，由内核触发, 通常以内核线程的方式运行. **特点是延迟执行**

> skip: 每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU 编号”，比如说 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd/0

以接收数据包为例子:

- 硬中断: 当网卡接收到数据包时,会通过硬中断通知内核, 这时候硬中断把数据包读入内存,更新硬件寄存器状态,发送软中断信号。
- 软中断: 当软件中断被信号唤醒时,需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。

### 查看软中断，和硬件中断指标

`/proc/softirqs` 提供了软中断的运行情况

`/proc/interrupts` 提供了硬中断的运行情况

这个文件是开机以来累积的次数,在排查问题时,如需要查看什么指标骤增,可以通过 `watch -d ` 命令.

```bash
$ cat /proc/softirqs
                    CPU0       CPU1
          HI:          0          0
       TIMER:     811613    1972736
      NET_TX:         49          7
      NET_RX:    1136736    1506885
       BLOCK:          0          0
    IRQ_POLL:          0          0
     TASKLET:     304787       3691
       SCHED:     689718    1897539
     HRTIMER:          0          0
         RCU:    1330771    1354737
```

1. 第一列表示软中断类型, 如 NET_TX 表示网络发送中断, NET_RX 表示网络接收中断.
2. 后面每列是不同 CPU 上对应不同的中断类型累积的触发的数量.
3. 注意同一种中断在不同 CPU 上的数量，比如网络接收和发送中断, 在不同的 CPU 上数量级应该是差不多的.

### 中断分配不均匀现象

这个现象通常是网卡不支持多队列导致的, 网卡队列技术(RSS) 支持 RSS 的网卡，通过多队列技术，每个队列对应一个中断号，通过对每个中断的绑定，可以实现网卡中断在 cpu 多核上的分配。

查看网卡是否支持多队列.

```bash
# 查看多队列是否生效
$ ls /sys/class/net/eth0/queues/

# 查看支持的队列数量
$ ethtool -l <name>
```

开启 irqbalance 服务(会根据 CPU 负载情况自动均衡 irq 到各个 CPU 上)

[网卡多队列及中断均衡](http://happyseeker.github.io/kernel/2016/07/15/multi-queue-of-net-device.html)
