## CPU 使用率

Linux 在运行任务的时候,通过 cpu 的时间划分为多个时间片，轮流来分配给进程使用。

Linux 通过内核中定义的 **HZ(节拍率)**,来触发时间中断,并使用全局变量 `jiffies` 记录了开机以来的节拍数量, 每发生一次时间中断, `jiffies` 的值就加 1, `jiffies` 可以理解为发生时间中断的总数, 而 `HZ` 可以理解为每秒触发多少次的时间中断. 节拍率是内核可配置项, 通过 `/boot/config` 可以查看他的配置。该中断的作用是为了定时更新系统日期和时间，使系统时间不断地得到跳转

```bash
cat /boot/config-$(uname -r)  |grep CONFIG_HZ
CONFIG_HZ_250=y
CONFIG_HZ=250
```

由于节拍率是内核选项, 所以用户空间不能直接访问, 为了方便用户空间直接使用, 内核还提供了一个用户空间节拍率, 它的值是固定的 100 也就是 1/100(10ms), 用户空间的进程使用这个值.

`/proc/stat` 提供的是系统的 CPU 和任务统计信息。比方说，如果你只关注 CPU 的话，可以执行下面的命令:

```bash
# 只保留各个 CPU 的数据
$ cat /proc/stat | grep ^cpu
cpu 280580 7407 286084 172900810 83602 0 583 0 0 0
cpu0 144745 4181 176701 86423902 52076 0 301 0 0 0
cpu1 135834 3226 109383 86476907 31525 0 282 0 0 0
```

第一行表示的是所有 CPU 的累加。其他列则表示不同场景下 CPU 的累加节拍数，它的单位是 USER_HZ，也就是 10 ms（1/100 秒），所以这其实就是不同场景下的 CPU 时间。

各列的参数可以通过 `man proc` 来查看细节

### CPU 使用率计算

通过 `/proc/stat` 来查看系统 cpu 使用情况

CPU 使用率，就是除了空闲时间外的其他时间占总 CPU 时间的百分比:

```text
CPU 使用率 = 1 - 空闲时间/总 CPU 时间
```

这里通过开机以来的节拍数累加值来计算, 所以是开机以来的平均cpu使用率,没什么参考价值, 一般为了计算cpu使用率都是取间隔时间内的使用率.

```text
时间单位内 CPU 使用率 = 1 - (new_idletime - old_idletime) / (new_totaltime - old_totaletime)
```

### 查看 CPU 使用率

通过一些工具来查看 CPU 使用率, 如 `htop` `top` `ps` `atop` 这些性能工具都是给出一段时间的平均 CPU 使用率,所以要注意间隔时间设置.如果多个工具对比分析要保证有相同的间隔时间.

比如，对比一下 top 和 ps 这两个工具报告的 CPU 使用率，默认的结果很可能不一样，因为 top 默认使用 3 秒时间间隔，而 ps 使用的却是进程的整个生命周期。

- top 显示了系统总体的 CPU 和内存使用情况,以及各个进程的资源使用情况, 各个进程中的 CPU 使用率, 是包含用户空间和内核空间使用率的总和.
- pidstat 可以查看每个进程中用户态和内核态的 CPU 使用率.
- ps 则只显示了每个进程的资源使用情况.

## CPU 使用率过高怎么办

通过上面等工具可以定位到具体的单个进程的 CPU 使用率较高的进程, 通过 `perf` 常用来分析系统的各种事件和内核性能,还可以用来分析应用程序的性能问题。

`perf` 中分析 `CPU` 的 2 中最常见的用法:

- `perf top` 类似与 top 实时显示占用 CPU 时钟最多的函数或者指令.

```bash
$ perf top
Samples: 833  of event 'cpu-clock', Event count (approx.): 97742399
Overhead  Shared Object       Symbol
   7.28%  perf                [.] 0x00000000001f78a4
   4.72%  [kernel]            [k] vsnprintf
   4.32%  [kernel]            [k] module_get_kallsym
   3.65%  [kernel]            [k] _raw_spin_unlock_irqrestore
...
```

1. Samples: 采样数
2. event: 事件类型
3. event count: 事件类型总数

1. 第一列 `Overhead`: 是该符号的性能事件在所有采样中的比例，用百分比来表示。
2. 第二列 `Shared`: 是该函数或指令所在的动态共享对象(Dynamic Shared Object)如内核、进程名、动态链接库名、内核模块名等。
3. 第三列 `Object`: 是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。
4. 最后一列 `Symbol`: 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。

- `perf record` 和 `perf report` record 提供了数据保存的功能, 而保存的数据可以使用 report 来查看,用于离线分析. 通过 -g 还可以开启调用关系采样.
