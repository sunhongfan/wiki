## 平均负载要如何理解

在遇到机器卡顿,或者某些服务响应变慢, 第一时间总是反应过来看看 `平均负载` 那这个指标到底要如何理解,并且定位性能出现问题的进程。

```bash
$ uptime
 14:10:10 up 1 day, 18:25,  4 users,  load average: 2.99, 2.83, 2.28
```

关键在与 `load average`, 这个指标列出了 1, 5, 15 分钟内的系统负载, 系统负载并不是 cpu 使用率.

平均负载: 指一定时间单位内,处于可运行状态 `R` 和 不可中断状态`D`的平均进程数量, 可以理解为平均活跃进程数量.

可运行状态: 指当前正在使用 CPU 或者 等待 CPU 的进程.

不可中断状态: 这种进程处于内核态的关键流程中,这些流程不能被打断,如进程等待 磁盘 I/O 响应,如果这时候中断了,容易导致数据丢失。

这个平均活跃的进程数量其实是相比较 CPU 数量决定, 如 2 个逻辑 CPU, 参考值如下:

1.   系统负载为 2, 表示一个活跃的进程占用 1 个 CPU, 此时 2 个 CPU 被占满.
2.   在 4 个 CPU 的机器上, 则系意味着 CPU 有百分之 50 的空闲.

### 平均负载多少时比较合理

当负载超过 cpu 数量时,系统就已经出现了过载,如超过一定的数值,则需要排查负载高的问题了。

1.   1,5,15 分钟平均负载值相差不大时,则证明系统负载平稳。
2.   1 分钟内负载很高,则证明系统负载在近 1 分钟突然增加
3.   5 分钟负载比 1 分钟的值要高时, 则证明系统负载正在下降.

### 平均负载高不一定是 cpu 使用率高

平均负载的指标包括了 活跃进程,和等待cpu 和等待 i/o 的进程。

而 cpu 使用率是单位时间内 cpu 繁忙的情况统计, 此时要根据具体进程来做判断:

1. 如 cpu 密集型程序, 会使用大量的 cpu 参与运算, 此时cpu 使用率较高。
2. 如 i/o 密集型程序, 数据库的读写, 更多的是与硬盘数据读写有关系,此时等待 i/o 会导致负载升高,但是不影响 cpu 使用率
3. 如多个进程轮换等待 cpu 的调度 此时 cpu 使用率和平均负载也会升高.

## 场景模拟

使用 stress 和 sysstat 包
1. stress 是系统压测工具
2. sysstat 包里包含了一些监控分析系统性能的命令。mpstat, pidstat
3. 命令不限于上面，也可以采用 htop 等一些指令。

### cpu 密集型程序

模拟 2 个进程来一直处于运行态的进程。

```bash
$ stress --cpu 2 --timeout 600
```

观察平均 1 分钟负载应在 接近 2 的状态

通过 mpstat 查看 cpu 使用率的情况, htop 也可以

```bash
$ mpstat -P ALL 5
Linux 5.4.0-100-generic (u-dev01)       03/06/2022      _x86_64_        (4 CPU)
02:44:49 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
02:44:54 PM  all   50.13    0.00    0.15    0.00    0.00    0.05    0.00    0.00    0.00   49.67
02:44:54 PM    0    0.00    0.00    0.00    0.00    0.00    0.20    0.00    0.00    0.00   99.80
02:44:54 PM    1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
02:44:54 PM    2    0.00    0.00    0.60    0.00    0.00    0.00    0.00    0.00    0.00   99.40
02:44:54 PM    3  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
```

1. 可以看到总 cpu 在用户空间使用了 50% 因为这里环境是 4 个cpu。
2. 然后发现 1 3 号 cpu 占用近 100%, 而 i/o wait 是 0 这说明是由于 cpu 使用率过高导致的负载升高。

得知是 cpu 使用率过高,定位进程。

```bash
# 通过 Htop 也可直观看到进程, P 根据 cpu 排序, 可发现 stress 的2个进程。
$ pidstat -u 5 1
Linux 5.4.0-100-generic (u-dev01)       03/06/2022      _x86_64_        (4 CPU)
02:48:05 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
02:48:10 PM     0    162724    0.00    0.20    0.00    0.00    0.20     3  sshd
02:48:10 PM     0    164666    0.00    0.20    0.00    0.00    0.20     0  kworker/0:3-events
02:48:10 PM     0    165019    0.00    0.20    0.00    0.00    0.20     3  kworker/3:0-mm_percpu_wq
02:48:10 PM     0    165039   99.60    0.00    0.00    0.40   99.60     3  stress
02:48:10 PM     0    165040  100.00    0.00    0.00    0.20  100.00     1  stress
02:48:10 PM     0    165136    0.40    0.40    0.00    0.00    0.80     2  htop
02:48:10 PM     0    165179    0.20    0.20    0.00    0.00    0.40     0  pidstat

Average:      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Average:        0    162724    0.00    0.20    0.00    0.00    0.20     -  sshd
Average:        0    164666    0.00    0.20    0.00    0.00    0.20     -  kworker/0:3-events
Average:        0    165019    0.00    0.20    0.00    0.00    0.20     -  kworker/3:0-mm_percpu_wq
Average:        0    165039   99.60    0.00    0.00    0.40   99.60     -  stress
Average:        0    165040  100.00    0.00    0.00    0.20  100.00     -  stress
Average:        0    165136    0.40    0.40    0.00    0.00    0.80     -  htop
Average:        0    165179    0.20    0.20    0.00    0.00    0.40     -  pidstat
```
1. 得知 1 3 cpu 是因为 stress 进程导致使用率占满.

### i/o 和 大量进程模拟.

```bash
# I/O 密集型进程，mpstat 会发现 cpu 在 用户和 系统空间并没有过多的占用,而是大量在等待 i/o
$ stress -i 1 --timeout 600

# 大量进程
# 8 个进程在争抢 4个 CPU，每个进程等待 CPU 的时间（也就是代码块中的%wait 列）高达 50%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。
$ stress -c 8 --timeout 600
```